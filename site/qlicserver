#!/usr/bin/perl -w
# avoid shell starter method here - otherwise we cannot kill the daemon
use 5.008;
use strict;
use threads;    ## REMOVE FOR UNTHREADED PERL
use Getopt::Std qw( getopts );
use Data::Dumper;
use POSIX qw();
import License;
import Qconf;
import Qstat;

###############################################################################
###############################################################################
# CUSTOMIZE THESE SETTINGS TO MATCH YOUR REQUIREMENTS:
#
my $config = {
    ## lookup:
    #   Map license 'features' (names) as provided by the license
    #   manager(s) to resources names (with long and short names).
    #   Features prefixed with '-' are reported but not managed.
    #
    #   format:
    #   feature => "name shortcut"
    #
    lookup => {
        -aihexa     => "hexa",
        -aimed      => "med",
        -aitetra    => "tetra",
        -ansys      => "ansys",
        -GTise      => "gtise",
        -HyperWorks => "hyper",
        -proam      => "proam",
        -prostar    => "prostar",
        GTpowerX    => "gtpower",
        NASTRAN     => "nastran",
        abaqus      => "abaqus",
        hpcdomains  => "starp",      # Star-CD parallel
        starsuite   => "stars",      # Star-CD serial
        starpar     => "starjob",    # Star-CD parallel starter
        JT          => "thomat",     # abaqus high temperature modelling
    },

    ## bundle:
    #   combine managed resources.
    #   good for software that can use alternative licenses
    #
    #   format:
    #   combined => "elem1 .. elemN"
    #
    bundle => {
        starcd => "starp stars",     # parallel/serial
    },

    ## urgency:
    #   How much extra weight to give to particular resources.
    #   If a 'slot' is weighted with 1000, we can give an extra 10%
    #   to a few resources
    #
    #   format:
    #   resource => INTEGER
    #
    urgency => { starcd => 100, },

    ## limit:
    #   The upper limit of the resource to be managed.
    #   Prevent applications from flooding the cluster and/or prevent
    #   jobs from consuming all the available licenses
    #
    #   format:
    #   resource => INTEGER
    #   resource => FLOAT < 1.0
    #
    limit => { gtpower => 4, nastran => 3, stars => 2, },

    ## trackonly:
    #   internal resources that are to be tracked, but not managed
    #
    #   format:
    #   space-delimited string
    #
    trackonly => "foam",

    ## config:
    #   various site configuration parameters - not yet implemented
    config => {
	## nthread => 0,
    },
};

#
#
# END OF CUSTOMIZE SETTINGS
###############################################################################
###############################################################################

#
# recast Bundle, Lookup Table(s), Track Only into array refs
#
for (
    values %{ $config->{bundle} },
    values %{ $config->{lookup} },
    $config->{trackonly},
  )
{
    $_ = [ (defined) ? split: () ];
}

#
# Track Only values cannot appear elsewhere
#
for my $ref ( $config->{bundle}, $config->{lookup} ) {
    delete @$ref{ map { $_ => "-$_" } @{ $config->{trackonly} } };
}

#
# repair Lookup Table as required - name and shortcut
#
for ( keys %{ $config->{lookup} } ) {
    $config->{lookup}{$_}[1] ||= $config->{lookup}{$_}[0] ||= $_;
}

#
# create reverse lookup - map complex to feature name
#
$config->{reverseLookup} = {
    map {
        my ($complex) = @{ $config->{lookup}{$_} };
        /^-/ ? () : ( $complex => $_ );
      }
      keys %{ $config->{lookup} }
};

#
# create an Alias Table, including 1:1 mappings
#
$config->{shortcut} = {
    ( map { $_ => $_ } keys %{ $config->{bundle} } ),
    (
        map { /^-/ ? () : reverse @{ $config->{lookup}{$_} } }
          keys %{ $config->{lookup} }
    ),
};

#
# remove invalid entries from urgency and limit
#
{
    my %hash = reverse %{ $config->{shortcut} };
    for my $ref ( $config->{limit}, $config->{urgency} ) {
        for ( keys %$ref ) {
            my $v = $ref->{$_};
            if ( exists $hash{$_} and defined $v and $v =~ /^\d+\.?\d*$/ ) {
                $v = sprintf "%.0f", $v if $v >= 1;    # no floats >= 1
            }
            else {
                delete $ref->{$_};
            }
        }
    }
}

( my $Script = $0 ) =~ s{^.*/}{};
my $CmdLine = join( " " => $Script, @ARGV );

our ( $VERSION, $DATE ) = do {
    my ( $ver, $date ) =
      q{$Id: qlicserver,v 1.26 2007/05/07 12:22:04 cfdadmin Exp $} =~
      m{\s+(\d+\.\d+).*?\s+(\d{4}[-/]\d{2}[-/]\d{2})};
    $date =~ s{/}{-}g;    # ISO-formatted

    ( $ver, $date );
};

# --------------------------------------------------------------------------
sub usage {
    $! = 0;               # clean exit
    warn "@_\n" if @_;
    die <<"USAGE";
usage: $Script [OPTION] [ARGS]
  Query availability of floating licenses for the GridEngine.

options:
   -c      show complex definitions (format as per 'qconf -sc')
           for possible inclusion via 'qconf -Mc ...'

   -C      provide initial values for
           'qconf -mattr exechost complex_values ... global'

   -d      daemonize.
           The optional argument is used as the delay [s] between queries
           (default: 60 seconds)

   -D      debug information for the developer

   -h      help

   -i      information about license features
           (generates text for the config lookup table)

   -k      kill running daemon

   -l resource=value,...
           similar to qsub(1), query the license server for the availability
           of the requested resource. A missing value is equal to 1.
           Exit with '99' if the condition cannot be satisfied.
           The resource 'slots' will be used to scale the license request.
           Returns the available resources.

   -n      suppress adjustment of the managed licenses (useful for testing).
           The output can be used directly for a load report:
           eg, "qlicserver -n | grep global:", but this is ill-advised

   -q      quiet(er) mode. Suppress output.

   -t SEC
           server query timeout (default: 15 seconds)

   -w      wake-up daemon from sleep

This program has 2 major modes:
  1. Adjust the number of managed licenses, based on license availability
     and number of granted resources (as determined by 'qstat')
     using the 'qconf -mattr exechost complex_values ... global' command

  2. Query the license server for the availability of requested resources.
     Exit with '99' (requeue) if the condition cannot be satisfied.
     Returns the available resources.

NOTES:
  The daemonize mode may be problematic for qmaster migration.
  Perhaps avoid 'setsid' and start it from a load-sensor.

  This code is provided as a courtesy to other users with absolutely
  no guarantees! Usage questions should be posted to the
  users\@gridengine.sunsource.net mailing list - please do not email
  the author directly.

version $VERSION ($DATE)
copyright (c) 2003-07 <Mark.Olesen\@ArvinMeritor.com>

Licensed and distributed under the Creative Commons
Attribution-NonCommercial-ShareAlike 2.5 License.
http://creativecommons.org/licenses/by-nc-sa/2.5
USAGE
}

# --------------------------------------------------------------------------
my %opt;
getopts( "hCcDdikl:nqt:w", \%opt );    # tolerate faults on unknown options
$opt{h} and usage();
my $Debugging ||= $opt{D};

my $host  = ( POSIX::uname() )[1];
my $admin = getpwuid($<);

License->timeout( $opt{t} ) if $opt{t};    # adjust timeout

# --------------------------------------------------------------------------
#
# Prototype: munge_licenses( REF1 [, REF2, [, REF3]] )
#
# HASHREF1 => {		# from the license manager
#    feature => {
#       total => NUM,
#       "user@machine nlicense" => occurances,
#       "*user@machine" => NUM,		## waiting licenses
#       ...
#    },
# }
#
# HASHREF2 => {		# from qstat
#    complex => {
#       waiting => {
#          "*user" => NUM,
#       },
#       jobid => {
#          "user@machine nlicense" => occurances,
#          ...
#       },
#       total => NUM,  # iff. an internal tracked value
#    },
# }
#
# HASHREF3 => {		# ulimit
#    complex => NUM,
# }
#
# munge into
#
# HASHREF => {
#    complex => {
#       info => {
#          extern  => NUM,
#          intern  => NUM,
#          limit   => NUM,
#          total   => NUM,
#          waiting => NUM,
#       },
#       extern  => { "user@machine" => NUM, },
#       intern  => { "user@machine" => NUM, },
#       waiting => { "*user" => NUM, },
#    },
# }

sub munge_licenses {
    my $daemon   = shift;
    my $consumed = shift || {};
    my $limits   = shift || {};
    my $report   = {};

    #
    # interprete aliases for consumed licenses
    #
    for my $complex ( keys %$consumed ) {
        my $rc = $config->{shortcut}{$complex} or next;
        my $entry = delete $consumed->{$complex};
        for my $job ( keys %$entry ) {
            for ( keys %{ $entry->{$job} } ) {
                $consumed->{$rc}{$job}{$_} += $entry->{$job}{$_} || 0;
            }
        }
    }

    #
    # * Cast the interesting features into the desired format.
    # * Include 'intern' usage, but do not adjust 'extern' yet.
    #
    for my $feature ( keys %$daemon ) {
        my $ignore;
        my $extern = $daemon->{$feature} or next;
        my $lookup = $config->{lookup}{$feature}
          || ( $ignore++, $config->{lookup}{"-$feature"} )
          || next;
        my ($resource) = @$lookup;

        # internal job allocation, jobs waiting
        my $intern  = delete( $consumed->{$resource} ) || {};
        my $waiting = delete( $intern->{waiting} )     || {};

        # resource, shortcut, flags
        # my ( $resource, undef, $flags ) = @$lookup;
        my $total = delete $extern->{total} || 0;    # remove 'total' from hash

        # potential management limits
        my $limit = $limits->{$resource};
        if ( defined $limit and $limit < 1 ) {
            $limit = sprintf "%.0f", ( $limit * $total );
        }
        defined $limit and $limit < $total or $limit = $total;

        $report->{$resource} = {
            flags   => $ignore,
            info    => { total => $total, limit => $limit, },
            extern  => $extern,
            intern  => $intern,
            waiting => $waiting,
        };
    }

    # add in tracked features
    for my $resource ( keys %$consumed ) {
        my $total = delete $consumed->{$resource}{total} or next;

        # internal job allocation, jobs waiting
        my $intern  = delete( $consumed->{$resource} ) || {};
        my $waiting = delete( $intern->{waiting} )     || {};

        $report->{$resource} = {
            flags   => -intern,
            info    => { total => $total, limit => $total },
            extern  => {},
            intern  => $intern,
            waiting => $waiting,
        };
    }

    #
    # bundled resources:
    # external licenses are the external licenses of the components
    #
    for my $resource ( keys %{ $config->{bundle} } ) {
        my $intern  = delete( $consumed->{$resource} ) || {};
        my $waiting = delete( $intern->{waiting} )     || {};

        my $entry = $report->{$resource} = {
            info    => { total => 0, limit => 0, },
            extern  => {},
            intern  => $intern,
            waiting => $waiting,
        };

        for my $part (
            grep { defined }
            map  { $report->{$_} } @{ $config->{bundle}{$resource} }
          )
        {
            $entry->{info}{total} += $part->{info}{total} || 0;
            $entry->{info}{limit} += $part->{info}{limit} || 0;

            for ( keys %{ $part->{extern} } ) {
                $entry->{extern}{$_} += $part->{extern}{$_};
            }
        }
    }

    # remove usage that is already accounted for
    # remove non-existent / implausible entry
    # prepend jobid with -ve to avoid it being processed more than once
    my $juggle = sub {
        my ( $extern, $intern ) = @_;
        for my $job ( grep { $_ > 0 } keys %$intern ) {
            for ( keys %{ $intern->{$job} } ) {
                if ( $extern->{$_} and $extern->{$_} >= $intern->{$job}{$_} ) {
                    $extern->{$_} -= $intern->{$job}{$_};
                    $intern->{"-$job"}{$_} = delete $intern->{$job}{$_};
                    $extern->{$_} > 0 or delete $extern->{$_};
                }
            }
            ## remove empty hash references
            keys %{ $intern->{$job} } or delete $intern->{$job};
        }
    };

    for my $resource ( keys %$report ) {
        my $entry   = $report->{$resource};
        my $extern  = $entry->{extern} or next;    # cannot happen
        my $intern  = $entry->{intern} or next;
        my $waiting = $entry->{waiting} ||= {};

        #
        # juggle extern/intern consumption
        #
        $juggle->( $extern, $intern );

        #
        # reduce extern and intern to canonical form "user@host" => count
        #
        for ( [ extern => $extern ], [ intern => $intern ] ) {
            my ( $label, $ref ) = @$_;
            for my $r ( $label =~ /intern/ ? values %$ref : $ref ) {
                my %hash;
                for ( keys %$r ) {
                    my ( $key, $value ) = split;
                    defined $value or $value = 1;    # for pre-reduced format
                    my $count = $r->{$_};
                    $hash{$key} += $value * $count;
                }
                %$r = %hash;
            }
        }

        #
        # juggle again - licenses may be split across several groups or servers
        #
        $juggle->( $extern, $intern );

        #
        # collapse one level of indirection and drop job numbers
        #   intern => {
        #     jobid => {
        #       "user@machine" => count,
        #     },
        #   },
        # -->
        #   intern => {
        #     "user@machine" => count,
        #   },
        %$intern = do {
            my %hash;
            for my $ref ( values %$intern ) {
                $hash{$_} += $ref->{$_} for keys %$ref;
            }
            %hash;
        };

        # add licenses reported as waiting by FlexLM
        for ( grep { /^\*/ } keys %$extern ) {
            $waiting->{$_} += delete $extern->{$_};
        }

        #
        # remove needless limiters
        #
        if (   $entry->{info}{limit} >= $entry->{info}{total}
            or $entry->{flags} )
        {
            delete $entry->{info}{limit};
        }

        # summarize usage
        #
        for (
            [ extern  => $extern ],
            [ intern  => $intern ],
            [ waiting => $waiting ],
          )
        {
            my ( $label, $ref ) = @$_;
            my $total;
            $total += $_ for values %$ref;
            $entry->{info}{$label} = $total || 0;
        }
    }

    return $report;
}

sub stringify_hashref {
    join ',' => map {
        my $r = $_;
        ref $r ? join ',' => map { "$_=$r->{$_}" } sort keys %$r : '';
    } @_;
}

#
# Prototype generate_output(HASHREF)
#
# HASHREF => {
#    feature => {
#       info => {
#          extern  => NUM,
#          intern  => NUM,
#          limit   => NUM,
#          total   => NUM,
#          waiting => NUM,
#       },
#       extern  => { "user@machine" => NUM, },
#       intern  => { "user@machine" => NUM, },
#       waiting => { "*user" => NUM, },
#    },
# }
sub generate_output {
    my $report = shift;
    my $rc;

    #
    # write dates, administration information, some environment variables
    # write shortcuts -> full complex names
    if (1) {    # disable if you wish
        my $time = time;
        my $date = POSIX::strftime( "%FT%T%z", localtime $time );

        local $, = "\n";
        print +(
            qq{<cmdline>$CmdLine</cmdline>},
            qq{<version>$VERSION</version>},
            qq{<host>$host</host>},
            qq{<admin>$admin</admin>},
            qq{<time epoch="$time">$date</time>},
            '',
            qq{<env>},
            (
                map { "$_=" . ( $ENV{$_} || "NONE" ); }
                  qw(
                  SGE_ROOT
                  SGE_CELL
                  SGE_ARCH
                  SGE_BINARY_PATH
                  SGE_qmaster
                  ),
                License->env(),
            ),
            qq{</env>},
            '',
            (
                map {
                    my ( $short, $full ) = ( $_, $config->{shortcut}{$_} );
                    $short eq $full
                      ? ()
                      : qq{<alias name="$short">$full</alias>};
                  } sort keys %{ $config->{shortcut} }
            ),
            (
                map { qq{<bundle name="$_">@{$config->{bundle}{$_}}</bundle>} }
                  sort keys %{ $config->{bundle} }
            ),
            '',
            qq{<licenses>},
            '',
        );
    }

    for my $resource ( sort keys %$report ) {
        my $entry = $report->{$resource}
          or warn "(WW) '$resource' not defined\n"
          and next;

        my ( $total, $limit, $ext_count, $int_count, $wait_count ) =
          @{ $entry->{info} }{qw( total limit extern intern waiting )};

        my ( $ignore, $extern, $intern, $waiting ) =
          @{$entry}{qw( flags extern intern waiting )};

        defined $limit and $limit < $total or undef $limit;

        my $managed = ( $total - $ext_count );
        if ( defined $limit and $managed > $limit ) {
            $managed = $limit;
        }
        my $free = $managed - $int_count;

        $_ >= 0 or $_ = 0 for ( $free, $managed );    # should not be required

        # accumulate in summary hash
        if ( not $ignore or $ignore and $ignore =~ /intern/ ) {
            $rc->{total}{$resource}   = $total;
            $rc->{limit}{$resource}   = $limit if defined $limit;
            $rc->{extern}{$resource}  = $ext_count;
            $rc->{intern}{$resource}  = $int_count;
            $rc->{free}{$resource}    = $free;
            $rc->{managed}{$resource} = $managed;
        }

        for (
            [ total   => $total ],
            [ limit   => $limit ],
            [ extern  => $ext_count ],
            [ intern  => $int_count ],
            [ waiting => $wait_count ],
          )
        {
            my ( $tag, $count ) = @$_;
            print "$tag=$resource=$count\n" if $count;
        }

        if ($ignore) {
            if ( $ignore =~ /intern/ ) {
                print "global==$resource==$free\n";
            }
            else {
                print "global=$resource=$free\n";
            }
        }
        else {
            print "global:$resource:$free\n";
        }

        my %user;
        for my $ref ( $extern, $intern, $waiting ) {
            $user{$_} += $ref->{$_} || 0 for keys %$ref;
        }

        for my $tag ( sort keys %user ) {
            my $count = $user{$tag};
            print "$tag=$resource=$count\n" if $count;
        }

        print "\n";
    }
    print "</licenses>\n";
    print "<accounting>\n";

    for (
        [ rc_limit   => $rc->{limit} ],
        [ rc_total   => $rc->{total} ],
        [ rc_extern  => $rc->{extern} ],
        [ rc_intern  => $rc->{intern} ],
        [ rc_managed => $rc->{managed} ],
        [ available  => $rc->{free} ],
      )
    {
        my ( $tag, $ref ) = @$_;
        print "$tag\t", stringify_hashref($ref), "\n";
    }
    print "</accounting>\n";
}

select STDOUT;
$| = 1;    # no output buffering

sub kill_daemon {
    my $signal = shift || 9;
    my @list =
      grep { $_ != $$ }
      map  { /^\s*(\d+)\s*$/ } qx{ps -C $Script -o pid= 2>/dev/null};
    kill $signal => @list if @list;
}

# ---------------------------------------------------------------------------
# '-k'
# terminate processes
# ---------------------------------------------------------------------------
if ( $opt{k} ) {
    kill_daemon 15;    # TERM
    exit 0;
}

# ---------------------------------------------------------------------------
# '-w'
# wakeup daemon
# ---------------------------------------------------------------------------
if ( $opt{w} ) {
    kill_daemon 10;    # USR1
    exit 0;
}

# ---------------------------------------------------------------------------
# '-c' / '-C'
# configuration
# ---------------------------------------------------------------------------
if ( $opt{C} or $opt{c} ) {
    my %hash = reverse %{ $config->{shortcut} };

    #
    # show complexes (format as per 'qconf -sc');
    #
    if ( $opt{c} ) {
        print <<'PRINT';
#
# complexes for re-importing via "qconf -mc",
# licenses mostly weighted with '0' urgency (slot count used instead)
#
# name shortcut type relop requestable consumable default urgency
# --------------------------------------------------------------------------
PRINT
        for ( sort keys %hash ) {
            print "$_\t$hash{$_}\tINT\t<=\tYES\tYES\t0\t",
              ( $config->{urgency}{$_} || 0 ), "\n";
        }
    }

    if ( $opt{C} ) {
        $_ = 0 for values %hash;

        print <<'PRINT';
#
# initialize managed complexes with the following command
# --------------------------------------------------------------------------
PRINT
        print "qconf -mattr exechost complex_values ",
          stringify_hashref( \%hash ), " global\n";
    }

    exit 0;
}

# ---------------------------------------------------------------------------
# '-i'
# query the license servers for available license features
# ---------------------------------------------------------------------------
if ( $opt{i} ) {
    my $license = License->query();

    print "\tlookup => {\t# license features from server\n";

    for ( sort keys %$license ) {
        my ( $comment, $feature, $lookup ) = ( "", $_, lc $_ );

        if ( $config->{lookup}{$_} ) {
            ($lookup) = @{ $config->{lookup}{$_} };
        }
        elsif ( $config->{lookup}{"-$feature"} ) {
            $feature = "-$feature";
            $comment = "\t## reported but unmanaged";
            ($lookup) = @{ $config->{lookup}{$feature} };
        }
        else {
            $comment = "\t## new";
        }

        print qq{\t\t"$feature"\t\t=> "$lookup",$comment\n};
    }

    print "\t},\n", "\t#\n";
    exit 0;
}

# ---------------------------------------------------------------------------
# '-l resource=value,...'
# query the license server for the availability
# ---------------------------------------------------------------------------
if ( $opt{l} ) {
    my %hash = reverse %{ $config->{shortcut} };

    # comma -> space-delimited
    my @list = map { s/,/ /g; split; } $opt{l};

    # number of slots ('slots=' or 's=')
    my ($slots) = map { /^(?:s|slots)=(\d+)$/ } @list;
    $slots ||= 1;

    # only check resources managed here
    @list = map {
        my ( $rc, $limit ) = split /=+/;
        $rc = $config->{shortcut}{$rc} || $rc;
        defined $limit and $limit =~ /^\d+\.\d*$/ or $limit ||= 1;
        $hash{$rc} ? [ $rc => sprintf "%.0f", $limit * $slots ] : ();
    } @list;

    @list or exit 0;

    my $licenses = munge_licenses( License->query() );

    my $failed;
    for (@list) {
        my ( $rc, $requested ) = @$_;
        if ( exists $licenses->{$rc} ) {    # only check licenses
            my ( $total, $extern, $intern ) =
              @{ $licenses->{$rc}{info} }{qw( total extern intern )};

            my $free = $total - ( $extern + $intern );
            unless ( $requested <= $free ) {
                $requested = $free;
                $failed++;
            }
        }
        $_ = "$rc=$requested";
    }
    print join( ',' => @list ), "\n" unless $opt{q};

    exit( $failed ? 99 : 0 );
}

# ---------------------------------------------------------------------------
# standard query, with optional '-d' (daemonize)
# ---------------------------------------------------------------------------
my $daemon = $opt{d};
if ($daemon) {    # daemonize
    ( my $delay = (shift) || '' );    # delay from command args
    $delay =~ /^\d+$/ or undef $delay;
    $daemon = $delay || 60;           # provide default delay

    # terminate old processes
    kill_daemon 15;                   # TERM
    my $ppid = getppid();             # get ppid *before* forking
    my $pid  = fork;
    exit if $pid;                     # let parent exit
    defined $pid or die "Couldn't fork: $!";

    # this needs more testing ...
    # option 1:
    # - avoid setsid and let child die with parent
    # option 2:
    # - use setsid and watch the original parent process

    # create a new process group
    # - or leave it as a sub-process of the loadsensor?
    POSIX::setsid() or die "Can't start a new session: $!";

    #
    # this makes the code quasi-independent of the parent process
    # but should allow it to detect when the launching load-sensor
    # has restarted
    #
    *processing = sub {
        if ( $daemon > 0 and kill 0 => $ppid )
        {    # daemon still running and ppid still alive
            sleep( $daemon || 0 );
        }
        else {
            $daemon = 0;    # ppid looks dead - let's die too
        }
        return $daemon;
    };
}
else {
    *processing = sub {
        sleep( $daemon || 0 );
        return $daemon;
    };
}

if ($daemon) {
    ## Trap fatal signals, setting flag to exit gracefully
    $SIG{INT} = $SIG{TERM} = sub { $daemon = 0; };
    $SIG{PIPE} = "IGNORE";
    $SIG{USR1} = sub { sleep 0; };    # allow wake-up on demand
    $SIG{USR2} = sub {
        sleep 0;                      # wake-up
        $daemon = -1;                 # signal end
    };
}

#
# the main license query and 'qconf -mattr' code
# standard - execute once
# daemon   - loop until killed
do {
    my $served = License->query();
    my $qstat  = Qstat->query();
    my $qconf  = Qconf->query();

    #
    # add in the tracked resources
    #
    for ( @{ $config->{trackonly} } ) {
        $qstat->{$_}{total} = $qconf->{$_} if exists $qconf->{$_};
    }

    #
    # assign 'total => 0' for managed licenses that were not
    # reported from the server (eg, server down)
    #
    for ( values %{ $config->{reverseLookup} } ) {
        $served->{$_} ||= { total => 0 };
    }

    my $licenses = munge_licenses( $served, $qstat, $config->{limit} );
    my $change = Qconf->diff( $qconf, $licenses );

    unless ( $opt{q} ) {
        generate_output($licenses);

        print "\n# adjustment of managed licenses"
          . ( $opt{n} ? " is -disabled-" : '' ) . "\n",
          "qconf -mattr exechost complex_values "
          . ( stringify_hashref($change) || "NONE" )
          . " global\n";
    }

    if ($Debugging) {
        $opt{n}++;
        die Data::Dumper->Dump( [ $licenses, $change ], [qw(License Change)] ),
          "\n";
    }

    Qconf->mattr( stringify_hashref($change) ) unless $opt{n};

} while processing();

exit 0;

# --------------------------------------------------------------------------
# the qx// command with a simple timeout wrapper

package Shell;

sub cmd {
    my ( $caller, %var ) = @_;
    my $command = $var{cmd}     || '';
    my $timeout = $var{timeout} || 0;
    my @lines;

    if ( ref $command eq "ARRAY" ) {
        $command = "@$command";
    }

    eval {
        local $SIG{ALRM} = sub { die "TIMEOUT\n" };    # NB: '\n' required
        alarm $timeout if $timeout;
        $command or die "$caller: Shell->cmd with an undefined query\n";
        @lines = qx{$command 2>&1};
        die "(EE) ", @lines if $?;
        alarm 0;
    };

    if ($@) {
        if ( $@ eq "TIMEOUT\n" ) {
            warn "(WW) TIMEOUT after $timeout seconds on '$command'\n";
            return undef;
        }
        else {
            die $@;    # propagate unexpected errors
        }
    }

    wantarray ? @lines : join '' => @lines;
}

1;

# --------------------------------------------------------------------------
# FlexLM queries
#
# The env variable 'LM_LICENSE_FILE' contains a colon-delimited list
# with "port@server:port@server".
# The queries for the same server (but different ports) are grouped together

package Flexlm;
our ( $query, $env, $timeout, @servers );

BEGIN {
    $env     = "LM_LICENSE_FILE";
    $timeout = 15;
    $query   = "lmutil lmstat -a -c";    # prefix for the query

    if ( my $value = $ENV{$env} ) {
        my %index;
        my $index = 0;
        @servers = ();

        for ( map { s{[:;]+}{ }g; split } $value ) {
            my $name = $_;
            if ( $name =~ s/^\d*\@// ) {    ## port@server or @server
                $name =~ s/\..+$//;         ## unqualified name
            }
            if ( defined $index{$name} ) {
                $servers[ $index{$name} ] .= ":$_";
            }
            else {
                $index{$name} = $index++;
                push @servers, $_;
            }
        }

        push @License::Manager, __PACKAGE__;
    }
    else {
        ## warn "(WW) ", __PACKAGE__, ": skip query, '\$$_' not set\n";
        undef $query;
    }
}

sub env {
    return $env;
}

sub timeout {
    my ( $caller, $value ) = @_;
    ( $value ||= 0 ) > 0 or $value = 15;
    $timeout = $value;
}

# --------------------------------------------------------------------------
# PARSE Flexlm output that looks like this
#
# Users of PATRAN:  (Total of 7 licenses available)
#
#  "PATRAN" v2003.1130, vendor: MSC
#  floating license
#
#    user1 host1 host1 (v2002.0120) (license.server.domain/port 861), start Fri 1/31 11:00
#    user2 host2 host2 (v2001.0523) (license.server.domain/port 1007), start Fri 1/31 12:24
#    user3 host3 /dev/pts/0 (v1999.1020) (license.server.domain/port 352), start Fri 1/31 13:11
#
# --------------------------------------------------------------------------
#
# Note that 'lmstat' also seems to use entries from the ~/.flexlmrc file and/or
# daemon-specific environment variables such as '*_LICENSE_FILE'.
#
# We thus limit the query to the entries explicitly found in LM_LICENSE_FILE
#
# return:
# HASHREF => {
#    feature => {
#       total  => number,
#       "user@machine nlicense" => occurances,
#       "user@machine nlicense" => occurances,
#    },
# }
#

sub query_server {
    my ( $caller, $server ) = @_;
    my $license = {};

    $server ||= join( ":" => @servers );

    my @lines = Shell->cmd(
        cmd     => "$query $server",
        timeout => $timeout,
    );

    defined $lines[0] or return $license;

    # warn "parse <@lines>\n";
    my $feature;
    for (@lines) {
        defined or next;

        ## capture error status
        ## e.g. Users of DesignWare-Regression:  (Error: 10 licenses, unsupported by licensed server)
        if ( my ( $what, $total ) =
/^Users \s+ of \s+ (\S+?): .+? [Ee]rror:\s+ (\d+) \s+ licen[cs]e/mgcx
          )
        {
            $feature = $what;
            $license->{$feature} ||= { total => 0 };
            next;
        }

        ## extract total licenses available, record the 'feature' name
        if ( my ( $what, $total ) =
            /^Users \s+ of \s+ (\S+?): .+? \s+ (\d+) \s+ licen[cs]e/mgcx )
        {
            $feature = $what;
            $license->{$feature}{total} += $total;
            next;
        }

        $feature and exists $license->{$feature} or next;

        # lines with ", start" indicate a license is in use
        #
        # 'user' and 'machine' are the first 2 entries
        #
        if (/, \s+ start \s+/x) {
            my ($count) = /(\d+) \s+ licen[cs]e/x;
            $count ||= 1;

            my ( $user, $host ) = map { lc } split;
            $host =~ s/\..*$//;    # unqualified hostname

            $license->{$feature}{"$user\@$host $count"}++;
            next;
        }

        # add in queued licenses
        # identify with '*' prefix
        if ( my ($count) = /\s+ queued \s+ for  \s+ (\d+) \s+ licen[cs]es/x ) {
            my ( $user, $host ) = map { lc } split;
            $host =~ s/\..*$//;    # unqualified hostname

            $license->{$feature}{"*$user\@$host"} += $count || 1;
            next;
        }
    }

    return $license;
}

# spawn threads and merge results from multiple 'query_server' calls
sub query {
    my $caller    = shift;
    my $nothreads = shift;

    if ( $nothreads or @servers <= 1 ) {
        return $caller->query_server();
    }

    ## REMOVE REMAINDER FOR UNTHREADED PERL

    my @threads;    # record the thread ids here

    for my $server (@servers) {
        my $thr = threads->create( sub { $caller->query_server($server) } );
        if ( defined $thr ) {
            push @threads, $thr;
        }
        else {
            warn "could not start thread for server $server\n;";
        }
    }

    # collect data, waiting for all threads to finish
    my @returned;
    for my $thr (@threads) {
        push @returned, $thr->join();
    }

    # merge results together - traverse a list of hash-of-hashes
    my $license = {};
    for my $hash (@returned) {
        for my $feature ( keys %$hash ) {
            my $subhash = $hash->{$feature};
            for my $k ( keys %$subhash ) {
                my $v = $subhash->{$k};
                $license->{$feature}{$k} += $v;
            }
        }
    }

    return $license;
}

1;

# --------------------------------------------------------------------------
# a class for combining several types of license managers
# assumes that the same license feature cannot be managed by more than
# a single license manager

package License;

sub timeout {
    my ( $caller, $value ) = @_;
    ( $value ||= 0 ) > 0 or $value = 15;
    $_->timeout($value) for @License::Manager;
}

sub query {
    my ($caller) = @_;
    return +{ map { %{ $_->query() } } @License::Manager };
}

sub env {
    my ($caller) = @_;
    return map { $_->env() } @License::Manager;
}

1;

# --------------------------------------------------------------------------
# provide paths to GridEngine bin/ and utilbin/

package Sge;
our ( $bin, $utilbin );

BEGIN {
    $bin     = $ENV{SGE_BINARY_PATH} || '';
    $utilbin = $ENV{SGE_utilbin}     || '';

    if ( -d ( $ENV{SGE_ROOT} || '' ) ) {
        my $arch = $ENV{SGE_ARCH}
          || qx{$ENV{SGE_ROOT}/util/arch}
          || 'NONE';

        chomp $arch;

        -d $bin     or $bin     = "$ENV{SGE_ROOT}/bin/$arch";
        -d $utilbin or $utilbin = "$ENV{SGE_ROOT}/utilbin/$arch";
    }

    for ( $bin, $utilbin ) {
        if ( -d $_ ) {
            s{/*$}{/};
        }
        else {
            $_ = '';
        }
    }

    $ENV{SGE_SINGLE_LINE} = 1;    # do not break up long lines with backslashes
}

1;

# --------------------------------------------------------------------------
package Qconf;
our ($timeout);

BEGIN {
    $timeout              = 10;
    $ENV{SGE_SINGLE_LINE} = 1;    # do not break up long lines with backslashes
}

sub timeout {
    my ( $caller, $value ) = @_;
    ( $value ||= 0 ) > 0 or $value = 15;
    $timeout = $value;
}

# query 'complex_values' from the global host
sub query {
    my $caller = shift;

    my @lines = Shell->cmd(
        cmd     => $Sge::bin . "qconf -se global",
        timeout => $timeout,
    );

    defined $lines[0] or return +{};

    return +{
        map {
            s/,/ /g;
            map { /^(.+)=(.+)\s*$/ } split;
          } grep { s/^\s*complex_values\s+// } @lines
    };
}

# set 'complex_values' of the global host
sub mattr {
    my $caller = shift;
    my $val    = shift;

    if ($val) {
        Shell->cmd(
            cmd => $Sge::bin
              . "qconf -mattr exechost complex_values $val global",
            timeout => 15,
        );
    }
}

# determine what exists in the globals and in complex_values and has changed
#
# Prototype ->diff( REF1, REF2 );
#
#
# HASHREF1 => {		# from the 'qconf -se global'
#    feature => total,
# }
#
# HASHREF2 => {		# from 'munge_licenses'
#     feature => {
#        flags => INT,
#        info  => { total => INT, limit => INT, extern => INT },
#        ...
#     }
# }
#
# determine the number of license that can be managed by the gridengine:
#   managed = total - external_count
#
sub diff {
    my $caller = shift;
    my ( $complex_values, $licenses ) = @_;
    my $changes = {};

    for my $resource ( keys %$complex_values ) {
        my $entry = $licenses->{$resource} or next;
        next if $entry->{flags};    # skip internal/ignored values

        my ( $total, $limit, $extern ) =
          @{ $entry->{info} }{qw( total limit extern )};

        my $managed = $total - $extern;

        if ( defined $limit and $limit < $managed ) {
            $managed = $limit;
        }

        $managed >= 0 or $managed = 0;    # should not be required

        $complex_values->{$resource} == $managed
          or $changes->{$resource} = $managed;
    }

    return $changes;
}

1;

# --------------------------------------------------------------------------
package Qstat;
our ($timeout);

BEGIN {
    $timeout = 15;
}

sub timeout {
    my ( $caller, $value ) = @_;
    ( $value ||= 0 ) > 0 or $value = 15;
    $timeout = $value;
}

# --------------------------------------------------------------------------
# PARSE qstat xml output that looks like this:
#
# <?xml version='1.0'?>
# <job_info  xmlns:xsd="http://www.w3.org/2001/XMLSchema">
#   <queue_info>
#     <job_list state="running">
#       <JB_job_number>934</JB_job_number>
#       <JAT_prio>0.56000</JAT_prio>
#       <JB_name>my_job_name</JB_name>
#       <JB_owner>user_name</JB_owner>
#       <state>r</state>
#       <JAT_start_time>11/30/2004 10:38:23</JAT_start_time>
#       <queue_name>cfd@host.domain</queue_name>
#       <slots>1</slots>
#       <hard_request name="license">1</hard_request>
#       <hard_req_queue>cfd</hard_req_queue>
#     </job_list>
#   </queue_info>
#   <job_info>
#   </job_info>
# </job_info>
# --------------------------------------------------------------------------

# extract
#   * <JB_job_number> <JB_owner> <slots> <hard_request> <queue_name>
# return:
# HASHREF => {
#    complex => {
#       waiting => {
#          "*user" => count,
#       },
#       jobid => {
#          "user@machine nlicense" => occurances,
#          "user@machine nlicense" => occurances,
#       },
#    },
# }
#
sub query {
    my $caller  = shift;
    my $license = {};

    my $lines = Shell->cmd(
        cmd     => $Sge::bin . "qstat -u '*' -xml -r -s prs",
        timeout => $timeout,
    ) or return $license;

    my %re = (
        state => qr{<state>([A-Za-z]+)</state>},
        slots => qr{<slots>(\d+)</slots>},
        job   => qr{<JB_job_number>(.+?)</JB_job_number>},
        user  => qr{<JB_owner>(.+?)</JB_owner>},
        host  => qr{<queue_name>.+?\@(.+?)</queue_name>},
    );

    for ( grep { $_ } split m{</job_list>}, $lines ) {
        my ($state) = /$re{state}/;
        my ($slots) = /$re{slots}/ or last;
        my ($user)  = /$re{user}/ or last;
        my ($job)   = /$re{job}/ or last;
        my ($host)  = /$re{host}/;

        ( $state ||= '' );

        if ( $state =~ /[qw]/ ) {
            while (
                s{<(\S*hard_request).*?\s+name=\"(\S+)\".*?>(\d[\.\d]*)</\1>}{})
            {
                my $name = $2;
                my $count = sprintf "%.0f", ( $3 * $slots );
                $license->{$name}{waiting}{"*$user"} += $count;
            }
        }
        else {
            $host or next;    # safety
            $host =~ s{\..*$}{};    # strip domain - unqualified host name
            my $identifier = "\L$user\@$host";
            while (
                s{<(\S*hard_request).*?\s+name=\"(\S+)\".*?>(\d[\.\d]*)</\1>}{})
            {
                my $name = $2;
                my $count = sprintf "%.0f", ( $3 * $slots );
                $license->{$name}{$job}{"$identifier $count"}++;
            }
        }
    }

    return $license;
}

1;

# --------------------------------------------------------------------------
