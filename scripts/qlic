#!/usr/bin/perl -w
use strict;
use Getopt::Std qw( getopts );
use POSIX qw( );

( my $Script = $0 ) =~ s{^.*/}{};

my $time = time;
my $date = POSIX::strftime( "%F %T", localtime $time );

$ENV{SGE_ROOT} or die "Error $Script: \$SGE_ROOT is not set\n";
$ENV{SGE_CELL} ||= "default";    # sge_cell

my ($siteLocation) = join "/" => ( $ENV{SGE_ROOT}, $ENV{SGE_CELL}, "site" );

my $config = {
    -site   => ( $siteLocation || '' ),
    -cache  => ( $siteLocation || '' ) . "/cache/" . "qlicserver.xml",
    -limits => ( $siteLocation || '' ) . "/" . "qlicserver.limits",
};

# ------------------------------------------------------------------------
# utils

# calculate age from epochs
sub age {
    my ( $a, $b ) = @_;
    my $diff = ( $a - $b );

    my $sign = '';
    if ( $diff < 0 ) {    # handle negatives
        $sign = '-';
        $diff = abs($diff);
    }

    sprintf "$sign%d:%02d:%02d",    # format into hh:mm:ss
      ( int $diff / 3_600 ),        # hh
      ( ( int $diff / 60 ) % 60 ),  # mm
      ( $diff % 60 );               # ss
}

# simple attribute parser
sub parseXMLattrib {
    my $str = shift;
    my %attr;

    if ( defined $str ) {
        ## get attr="value"
        for ($str) {
            while (s{^\s*(\w+)=\"([^\"]*)\"}{}s
                or s{^\s*(\w+)=\'([^\']*)\'}{}s )
            {
                $attr{$1} = $2;
            }
        }
    }

    %attr;
}

package LCache;

sub new {
    my $caller = shift;
    my $file   = shift;

    my $self = bless {
        ( map { $_ => {} } qw( -rc ) ),
        ( map { $_ => '' } qw( -date -host -age ) )
    }, $caller;

    -f $file or return $self;

    local $_ = do { local ( @ARGV, $/ ) = $file; <>; };

    # strip out all comments
    s{<!--.*?-->\s*}{}sg;

    # get the header section
    s{^(.+?)</query>}{}s or return;

    my $txt = $1;
    for ( split m{\n+}, $txt ) {
        if (m{<(host)>\s*(.+?)\s*</\1>}) {
            my ( $k, $v ) = ( $1, $2 );
            $self->{"-$k"} = $v;
        }
        elsif (m{<(time) \s+ .*? epoch=\"(\d+)\"\s*>\s*(.+?)\s*</\1>}x) {
            $self->{-age} = main::age( $time, $2 );
            $self->{-date} = $3;
        }
    }

    # only retain the <resources> contents
    s{^.*?<resources>}{}s and s{</resources>.*$}{}s or return;

    ## process <resource .../> and <resource ...></resource>
    while (s{<resource\s+([^<>]+)/>}{}s
        or s{<resource\s+([^<>]+)>\s*</resource>}{}s )
    {
        my %hash = main::parseXMLattrib($1);
        my $name = delete $hash{name};

        if ( defined $name ) {
            for my $k ( keys %hash ) {
                $self->{-rc}{$name}{$k} = $hash{$k} || 0;
            }
        }
    }

    ## process <resource ...> CONTENT </resource>
    while (s{<resource\s+([^<>]+)>(.+?)</resource>}{}s) {
        my ( $attr, $content ) = ( $1, $2 );
        my %hash = main::parseXMLattrib($attr);
        my $name = delete $hash{name};

        if ( defined $name ) {
            for my $k ( keys %hash ) {
                $self->{-rc}{$name}{$k} = $hash{$k} || 0;
            }
        }

        ## process <user ...> COUNT </user>
        while ( $content =~ s{<user\s+([^<>]+)>(\d+)</user>}{}s ) {
            my ( $attr, $count ) = ( $1, $2 );
            my %hash = main::parseXMLattrib($attr);
            my $user = delete $hash{name};
            my $host = delete $hash{host};

            if ( defined $user ) {
                if ( defined $host ) {
                    $self->{-rc}{$name}{-where}{"$user\@$host"} = $count;
                }
                else {
                    ## tag waiting with '[]'
                    $self->{-rc}{$name}{-where}{$user} = "[$count]";
                }
            }
        }
    }

    return $self;
}

sub query {
    my $self = shift;
    my @args = @_;
    %{ $self->{-rc} };
}

sub dump {
    use Data::Dumper;
    print Dumper( $_[0] );
}

sub available {
    my $self = shift;
    sort keys %{ $self->{-rc} };
}

package LLimit;

sub new {
    my $caller     = shift;
    my $diskValues = shift;

    my $self = bless {}, $caller;

    my $fileString;
    if ( defined $diskValues and -f $diskValues ) {
        $fileString = do {
            local *FILE;
            local $/;
            if ( open FILE, $diskValues ) {
                <FILE>;
            }
            else {
                undef;
            }
        };
    }
    elsif ( defined $diskValues and -d $diskValues ) {
        local *DIR;
        my $dir = $diskValues;
        if ( opendir DIR, $dir ) {
            my @files = grep { -f "$dir/$_" and -r _ } readdir DIR;
            for my $name (@files) {
                my $limit;

                # use the last value
                if ( open FILE, "$dir/$name" ) {
                    $limit = ( map { /^\s*(-?\d+)\s*$/ } <FILE> )[-1];
                }
                defined $limit or $limit = "NONE";
                $self->{$name} = $limit;
            }
        }
    }

    for ($fileString) {
        defined or next;

        # strip out all comments
        s{<!--.*?-->\s*}{}sg;

        ## process <resource .../> and <resource ...></resource>
        while (s{<resource\s+([^<>]+)/>}{}s
            or s{<resource\s+([^<>]+)>\s*</resource>}{}s )
        {
            my %hash  = main::parseXMLattrib($1);
            my $name  = delete $hash{name};
            my $limit = delete $hash{limit};
            if ( defined $name and defined $limit ) {
                $self->{$name} = $limit;
            }
        }
    }

    return $self;
}

sub change {
    my $caller     = shift;
    my $diskValues = shift;
    my @args       = @_;

    @args or return;

    my ( %pending, %adjusted );

    for (@args) {
        s/,/ /g;    # comma -> space-delimited

        my %h = map { /^(.+?)=(.*)$/ } split;
        for ( keys %h ) {
            defined $h{$_} and length $h{$_} or $h{$_} = "NONE";
            $pending{$_} = $h{$_};
        }
    }

    keys %pending or return;

    my $user = getpwuid $<;
    if ( defined $diskValues and -d $diskValues ) {
        local *DIR;
        my $dir = $diskValues;
        if ( opendir DIR, $dir ) {
            my @files = grep { -f "$dir/$_" and -w _ } readdir DIR;

            for my $name (@files) {
                if ( exists $pending{$name} ) {
                    local *FILE;
                    if ( open FILE, ">", "$dir/$name" ) {
                        print FILE "# adjusted by $user $date\n",
                          "$pending{$name}\n";
                        $adjusted{$name} = delete $pending{$name};
                    }
                }
            }
        }
    }

    for ( [ "adjusted" => \%adjusted ], [ "not adjusted" => \%pending ], ) {
        my ( $label, $href ) = @$_;
        keys %$href or next;
        print "$label: ",
          join( "," => map { qq{$_=$href->{$_}} } sort keys %$href ), "\n";
    }
}

sub output {
    my $self = shift;

    my @list = map { qq{$_=$self->{$_}} } sort keys %$self;

    print "limits: ";
    if (@list) {
        print join( "," => @list ), "\n";
    }
    else {
        print "NONE\n";
    }
}

# ------------------------------------------------------------------------

package main;
import LCache;

# ------------------------------------------------------------------------
sub usage {
    $! = 0;               # clean exit
    warn "@_\n" if @_;
    die <<"USAGE";
usage:
    $Script [OPTION]
    $Script [OPTION] resource=limit .. resource=limit

with options:
  -a       combined with '-u' = include active jobs
  -c FILE  alternative location for the license cache
  -C FILE  alternative location for the license limit
  -d       dump cache file as raw xml
  -D       dump license cache in perl format
  -f       display free licenses only
  -l       list license limit
  -q       display free licenses via qhost query
  -u       license usage via 'lacct'
  -U       license usage per user via 'lacct'
  -w       show who/where ('[]' indicates waiting jobs)
  -h       this help

* extract / display information for the GridEngine license cache
  $config->{-cache}

* adjust / display information for the license limits
  $config->{-limits}

copyright (c) 2003-09 <Mark.Olesen\@emconTechnologies.com>

Licensed and distributed under the Creative Commons
Attribution-NonCommercial-ShareAlike 2.5 License.
http://creativecommons.org/licenses/by-nc-sa/2.5
USAGE
}

# -------------------------------------------------------------------------
my %opt;
getopts( 'hac:C:DdflqUuw', \%opt ) or usage();
$opt{h} and usage();

# user-based usage
if ( $opt{U} ) {
    my @query = ( "lacct", "-u" );
    push @query, map { $opt{$_} ? "-$_" : () } qw( a );
    exec @query;
    exit 2;
}

if ( $opt{u} ) {
    my @query = "lacct";
    push @query, map { $opt{$_} ? "-$_" : () } qw( a w );
    exec @query;
    exit 2;
}

if ( $opt{d} ) {
    local $_;
    my $file = $opt{c} || $config->{-cache};

    if ( not -f $file and $file !~ m{/} ) {
        $file = "$config->{-site}/$file";
    }

    -f $file or exit 1;

    $_ = do { local ( @ARGV, $/ ) = $file; <>; };

    # do a basic check for well-formed xml
    # this might not be the case if there is a race condition
    # and the file has not been fully written

    # check for '<?xml version="1.0"?><someTag ...' at the start
    # and '</someTag>' at the end
    my ($tag) = m{^<\?xml [^<>]*\?>\s*\<(\w+)}sx;
    unless ( $tag and m{</\Q$tag\E>\s*$} ) {
        sleep 2;    ## wait and try again
        $_ = do { local ( @ARGV, $/ ) = $file; <>; };
    }

    $_ ||= '';      ## avoid uninitialized

    print;
    exit;
}

if ( $opt{q} ) {
    my %free =
      map  { /^\s+gc:(\S+?)=(\d\S*)\s*$/ }
      grep { /^global/ ... /^\S/ } qx{qhost -F};

    $_ += 0 for values %free;

    for ( sort keys %free ) {
        my $intval = $free{$_} + 0;    # normalize as integers
        print "$_=$intval\n";
    }
    exit;
}

if ( $opt{l} ) {
    my $info = LLimit->new( $opt{C} || $config->{-limits} );
    $info->output();
    exit;
}

if (@ARGV) {
    LLimit->change( $opt{C} || $config->{-limits}, @ARGV );
    exit;
}

my $info = LCache->new( $opt{c} || $config->{-cache} );
$info->dump() if $opt{D};

my %resources = $info->query();

#
# stringify hash ref as keyword=value
#
sub hashRefToString {
    map {
        my $ref = $_;
        ref $ref ? map { "$_=$ref->{$_}" } sort keys %$ref : ()
    } @_;
}

my @list;

format =
# name      total limit extern intern wait free
@<<<<<<<<<<< @>>>>> @>>>>> @>>>>> @>>>>> @>>>> @>>>>
@list
.

unless ( $opt{f} or $opt{w} ) {
    my @info = qw( host age );
    my ($len) = sort { $b <=> $a } map { length } @info;

    print map {
        my $k = sprintf "%-${len}s", $_;
        my $v = $info->{"-$_"};
        $v ? "$k = $v\n" : ();
    } @info;

    print "\n";

    @list = qw( resource total limit extern intern wait free );
    write;
    s/./-/g for @list;
    write;
}

for my $resource ( sort keys %resources ) {
    my $count = $resources{$resource} || {};
    if ( $opt{f} ) {
        my $free = $count->{free} || 0;
        print "$resource=$free\n" if $free;
    }
    elsif ( $opt{w} ) {
        @list = hashRefToString( $count->{-where} );
        if (@list) {
            my $fmt = "%-11s";
            my $indent = sprintf "\n$fmt", '';
            printf $fmt, $resource;
            print join( $indent => @list ), "\n";
        }
    }
    else {
        @list =
          ( $resource,
            @{$count}{qw( total limit extern intern waiting free )} );

        my $type = $resources{$resource}{type} || 0;

        # no total?
        $_ ||= "?" for $list[1];

        if ( $type eq "intern" ) {
            $_ = "*" for $list[3];
        }
        elsif ( $type eq "track" ) {
            $_ = "*" for $list[4];
        }

        # easy to read representation for zero
        for (@list) {
            defined $_ or $_ = '.';
        }

        write;
    }
}

# ------------------------------------------------------------------------
